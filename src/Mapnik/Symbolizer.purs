-- File auto generated by purescript-bridge! --
module Mapnik.Symbolizer where

import Data.Lens (Iso', Lens', Prism', lens, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe, Maybe(..))
import Data.Newtype (class Newtype)
import Data.Symbol (SProxy(SProxy))
import Mapnik.Color (Color)
import Mapnik.Common (Dash, Expression, FontFeatureSettings, PathExpression, Transform)
import Mapnik.Enums (ColorizerMode, CompositeMode, DebugMode, Direction, GammaMethod, HaloRasterizer, HorizontalAlignment, JustifyAlignment, LabelPlacement, LineCap, LineJoin, LineRasterizer, MarkerMultiPolicy, MarkerPlacement, PatternAlignment, PlacementDirection, PointPlacement, ScalingMethod, SimplifyAlgorithm, TextTransform, Upright, VerticalAlignment)
import Prim (Array, Boolean, Int, Number, String)

import Prelude
import Data.Generic.Rep (class Generic)
import Data.Foreign.Class (class Decode, class Encode, decode, encode)
import Data.Foreign.Generic (defaultOptions, genericEncode, genericDecode)
import Data.Foreign.Generic.Types (Options, SumEncoding(..))
import Data.Foreign.Generic.Class (class GenericDecode, class GenericEncode)
import Data.Generic.Rep.Eq as GEq
import Data.Generic.Rep.Show as GShow

import Data.Array (head)
import Data.Maybe (maybe)
import Data.Foreign (Foreign, F, ForeignError(..), toForeign, isNull)
import Control.Monad.Error.Class (throwError)
import Data.List.NonEmpty as NEL
import Data.StrMap as SM
import Data.Traversable (traverse)

decodeMay Nothing = pure Nothing
decodeMay (Just s) | isNull s = pure Nothing
decodeMay (Just s) = decode s

jOpts = defaultOptions { sumEncoding = ObjectWithSingleField, unwrapSingleConstructors = true}
data Symbolizer =
    PointSymbolizer {
      file :: Maybe PathExpression
    , opacity :: Maybe (Prop Number)
    , allowOverlap :: Maybe (Prop Boolean)
    , ignorePlacement :: Maybe (Prop Boolean)
    , pointPlacement :: Maybe (Prop PointPlacement)
    , imageTransform :: Maybe (Prop Transform)
    , simplifyTolerance :: Maybe (Prop Number)
    , smooth :: Maybe (Prop Number)
    , clip :: Maybe (Prop Boolean)
    , compOp :: Maybe (Prop CompositeMode)
    , geometryTransform :: Maybe (Prop Transform)
    , simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm)
    }
  | LineSymbolizer {
      offset :: Maybe (Prop Number)
    , lineRasterizer :: Maybe (Prop LineRasterizer)
    , strokeGamma :: Maybe (Prop Number)
    , strokeGammaMethod :: Maybe (Prop GammaMethod)
    , strokeDashArray :: Maybe (Prop (Array Dash))
    , strokeDashOffset :: Maybe (Prop Number)
    , strokeMiterLimit :: Maybe (Prop Number)
    , strokeWidth :: Maybe (Prop Number)
    , strokeOpacity :: Maybe (Prop Number)
    , stroke :: Maybe (Prop Color)
    , strokeLineJoin :: Maybe (Prop LineJoin)
    , strokeLineCap :: Maybe (Prop LineCap)
    , simplifyTolerance :: Maybe (Prop Number)
    , smooth :: Maybe (Prop Number)
    , clip :: Maybe (Prop Boolean)
    , compOp :: Maybe (Prop CompositeMode)
    , geometryTransform :: Maybe (Prop Transform)
    , simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm)
    }
  | LinePatternSymbolizer {
      file :: Maybe PathExpression
    , opacity :: Maybe (Prop Number)
    , offset :: Maybe (Prop Number)
    , imageTransform :: Maybe (Prop Transform)
    , simplifyTolerance :: Maybe (Prop Number)
    , smooth :: Maybe (Prop Number)
    , clip :: Maybe (Prop Boolean)
    , compOp :: Maybe (Prop CompositeMode)
    , geometryTransform :: Maybe (Prop Transform)
    , simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm)
    }
  | PolygonSymbolizer {
      fill :: Maybe (Prop Color)
    , fillOpacity :: Maybe (Prop Number)
    , gamma :: Maybe (Prop Number)
    , gammaMethod :: Maybe (Prop GammaMethod)
    , simplifyTolerance :: Maybe (Prop Number)
    , smooth :: Maybe (Prop Number)
    , clip :: Maybe (Prop Boolean)
    , compOp :: Maybe (Prop CompositeMode)
    , geometryTransform :: Maybe (Prop Transform)
    , simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm)
    }
  | PolygonPatternSymbolizer {
      file :: Maybe PathExpression
    , opacity :: Maybe (Prop Number)
    , gamma :: Maybe (Prop Number)
    , gammaMethod :: Maybe (Prop GammaMethod)
    , imageTransform :: Maybe (Prop Transform)
    , alignment :: Maybe (Prop PatternAlignment)
    , simplifyTolerance :: Maybe (Prop Number)
    , smooth :: Maybe (Prop Number)
    , clip :: Maybe (Prop Boolean)
    , compOp :: Maybe (Prop CompositeMode)
    , geometryTransform :: Maybe (Prop Transform)
    , simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm)
    }
  | RasterSymbolizer {
      scaling :: Maybe ScalingMethod
    , rasterOpacity :: Maybe Number
    , filterFactor :: Maybe Number
    , meshSize :: Maybe Int
    , preMultiplied :: Maybe Boolean
    , colorizer :: Maybe Colorizer
    , simplifyTolerance :: Maybe (Prop Number)
    , smooth :: Maybe (Prop Number)
    , clip :: Maybe (Prop Boolean)
    , compOp :: Maybe (Prop CompositeMode)
    , geometryTransform :: Maybe (Prop Transform)
    , simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm)
    }
  | ShieldSymbolizer {
      placements :: TextPlacements
    , imageTransform :: Maybe (Prop Transform)
    , dx :: Maybe (Prop Number)
    , dy :: Maybe (Prop Number)
    , opacity :: Maybe (Prop Number)
    , unlockImage :: Maybe (Prop Boolean)
    , file :: Maybe PathExpression
    , haloRasterizer :: Maybe (Prop HaloRasterizer)
    , simplifyTolerance :: Maybe (Prop Number)
    , smooth :: Maybe (Prop Number)
    , clip :: Maybe (Prop Boolean)
    , compOp :: Maybe (Prop CompositeMode)
    , geometryTransform :: Maybe (Prop Transform)
    , simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm)
    }
  | TextSymbolizer {
      placements :: TextPlacements
    , haloCompOp :: Maybe (Prop CompositeMode)
    , haloRasterizer :: Maybe (Prop HaloRasterizer)
    , haloTransform :: Maybe (Prop Transform)
    , simplifyTolerance :: Maybe (Prop Number)
    , smooth :: Maybe (Prop Number)
    , clip :: Maybe (Prop Boolean)
    , compOp :: Maybe (Prop CompositeMode)
    , geometryTransform :: Maybe (Prop Transform)
    , simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm)
    }
  | BuildingSymbolizer {
      fill :: Maybe (Prop Color)
    , fillOpacity :: Maybe (Prop Number)
    , height :: Maybe (Prop Number)
    , simplifyTolerance :: Maybe (Prop Number)
    , smooth :: Maybe (Prop Number)
    , clip :: Maybe (Prop Boolean)
    , compOp :: Maybe (Prop CompositeMode)
    , geometryTransform :: Maybe (Prop Transform)
    , simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm)
    }
  | MarkersSymbolizer {
      file :: Maybe PathExpression
    , opacity :: Maybe (Prop Number)
    , fill :: Maybe (Prop Color)
    , fillOpacity :: Maybe (Prop Number)
    , spacing :: Maybe (Prop Number)
    , maxError :: Maybe (Prop Number)
    , offset :: Maybe (Prop Number)
    , width :: Maybe (Prop Number)
    , height :: Maybe (Prop Number)
    , allowOverlap :: Maybe (Prop Boolean)
    , avoidEdges :: Maybe (Prop Boolean)
    , ignorePlacement :: Maybe (Prop Boolean)
    , imageTransform :: Maybe (Prop Transform)
    , placement :: Maybe (Prop MarkerPlacement)
    , multiPolicy :: Maybe (Prop MarkerMultiPolicy)
    , direction :: Maybe (Prop Direction)
    , strokeGamma :: Maybe (Prop Number)
    , strokeGammaMethod :: Maybe (Prop GammaMethod)
    , strokeDashArray :: Maybe (Prop (Array Dash))
    , strokeDashOffset :: Maybe (Prop Number)
    , strokeMiterLimit :: Maybe (Prop Number)
    , strokeWidth :: Maybe (Prop Number)
    , strokeOpacity :: Maybe (Prop Number)
    , stroke :: Maybe (Prop Color)
    , strokeLineJoin :: Maybe (Prop LineJoin)
    , strokeLineCap :: Maybe (Prop LineCap)
    , simplifyTolerance :: Maybe (Prop Number)
    , smooth :: Maybe (Prop Number)
    , clip :: Maybe (Prop Boolean)
    , compOp :: Maybe (Prop CompositeMode)
    , geometryTransform :: Maybe (Prop Transform)
    , simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm)
    }
  | GroupSymbolizer {
      groupProperties :: GroupSymProperties
    , numColumns :: Maybe (Prop Int)
    , startColumn :: Maybe (Prop Int)
    , repeatKey :: Maybe (Prop Expression)
    , placements :: TextPlacements
    , simplifyTolerance :: Maybe (Prop Number)
    , smooth :: Maybe (Prop Number)
    , clip :: Maybe (Prop Boolean)
    , compOp :: Maybe (Prop CompositeMode)
    , geometryTransform :: Maybe (Prop Transform)
    , simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm)
    }
  | DebugSymbolizer {
      mode :: Maybe DebugMode
    , simplifyTolerance :: Maybe (Prop Number)
    , smooth :: Maybe (Prop Number)
    , clip :: Maybe (Prop Boolean)
    , compOp :: Maybe (Prop CompositeMode)
    , geometryTransform :: Maybe (Prop Transform)
    , simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm)
    }
  | DotSymbolizer {
      fill :: Maybe (Prop Color)
    , opacity :: Maybe (Prop Number)
    , width :: Maybe (Prop Number)
    , height :: Maybe (Prop Number)
    , compOp :: Maybe (Prop CompositeMode)
    }

derive instance genericSymbolizer :: Generic Symbolizer _

instance encodeSymbolizer :: Encode Symbolizer where encode = genericEncode jOpts

instance decodeSymbolizer :: Decode Symbolizer where decode = genericDecode jOpts

instance showSymbolizer :: Show Symbolizer where show = GShow.genericShow

instance eqSymbolizer :: Eq Symbolizer where eq = GEq.genericEq


--------------------------------------------------------------------------------
_PointSymbolizer :: Prism' Symbolizer { file :: Maybe PathExpression, opacity :: Maybe (Prop Number), allowOverlap :: Maybe (Prop Boolean), ignorePlacement :: Maybe (Prop Boolean), pointPlacement :: Maybe (Prop PointPlacement), imageTransform :: Maybe (Prop Transform), simplifyTolerance :: Maybe (Prop Number), smooth :: Maybe (Prop Number), clip :: Maybe (Prop Boolean), compOp :: Maybe (Prop CompositeMode), geometryTransform :: Maybe (Prop Transform), simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm) }
_PointSymbolizer = prism' PointSymbolizer f
  where
    f (PointSymbolizer r) = Just r
    f _ = Nothing

_LineSymbolizer :: Prism' Symbolizer { offset :: Maybe (Prop Number), lineRasterizer :: Maybe (Prop LineRasterizer), strokeGamma :: Maybe (Prop Number), strokeGammaMethod :: Maybe (Prop GammaMethod), strokeDashArray :: Maybe (Prop (Array Dash)), strokeDashOffset :: Maybe (Prop Number), strokeMiterLimit :: Maybe (Prop Number), strokeWidth :: Maybe (Prop Number), strokeOpacity :: Maybe (Prop Number), stroke :: Maybe (Prop Color), strokeLineJoin :: Maybe (Prop LineJoin), strokeLineCap :: Maybe (Prop LineCap), simplifyTolerance :: Maybe (Prop Number), smooth :: Maybe (Prop Number), clip :: Maybe (Prop Boolean), compOp :: Maybe (Prop CompositeMode), geometryTransform :: Maybe (Prop Transform), simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm) }
_LineSymbolizer = prism' LineSymbolizer f
  where
    f (LineSymbolizer r) = Just r
    f _ = Nothing

_LinePatternSymbolizer :: Prism' Symbolizer { file :: Maybe PathExpression, opacity :: Maybe (Prop Number), offset :: Maybe (Prop Number), imageTransform :: Maybe (Prop Transform), simplifyTolerance :: Maybe (Prop Number), smooth :: Maybe (Prop Number), clip :: Maybe (Prop Boolean), compOp :: Maybe (Prop CompositeMode), geometryTransform :: Maybe (Prop Transform), simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm) }
_LinePatternSymbolizer = prism' LinePatternSymbolizer f
  where
    f (LinePatternSymbolizer r) = Just r
    f _ = Nothing

_PolygonSymbolizer :: Prism' Symbolizer { fill :: Maybe (Prop Color), fillOpacity :: Maybe (Prop Number), gamma :: Maybe (Prop Number), gammaMethod :: Maybe (Prop GammaMethod), simplifyTolerance :: Maybe (Prop Number), smooth :: Maybe (Prop Number), clip :: Maybe (Prop Boolean), compOp :: Maybe (Prop CompositeMode), geometryTransform :: Maybe (Prop Transform), simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm) }
_PolygonSymbolizer = prism' PolygonSymbolizer f
  where
    f (PolygonSymbolizer r) = Just r
    f _ = Nothing

_PolygonPatternSymbolizer :: Prism' Symbolizer { file :: Maybe PathExpression, opacity :: Maybe (Prop Number), gamma :: Maybe (Prop Number), gammaMethod :: Maybe (Prop GammaMethod), imageTransform :: Maybe (Prop Transform), alignment :: Maybe (Prop PatternAlignment), simplifyTolerance :: Maybe (Prop Number), smooth :: Maybe (Prop Number), clip :: Maybe (Prop Boolean), compOp :: Maybe (Prop CompositeMode), geometryTransform :: Maybe (Prop Transform), simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm) }
_PolygonPatternSymbolizer = prism' PolygonPatternSymbolizer f
  where
    f (PolygonPatternSymbolizer r) = Just r
    f _ = Nothing

_RasterSymbolizer :: Prism' Symbolizer { scaling :: Maybe ScalingMethod, rasterOpacity :: Maybe Number, filterFactor :: Maybe Number, meshSize :: Maybe Int, preMultiplied :: Maybe Boolean, colorizer :: Maybe Colorizer, simplifyTolerance :: Maybe (Prop Number), smooth :: Maybe (Prop Number), clip :: Maybe (Prop Boolean), compOp :: Maybe (Prop CompositeMode), geometryTransform :: Maybe (Prop Transform), simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm) }
_RasterSymbolizer = prism' RasterSymbolizer f
  where
    f (RasterSymbolizer r) = Just r
    f _ = Nothing

_ShieldSymbolizer :: Prism' Symbolizer { placements :: TextPlacements, imageTransform :: Maybe (Prop Transform), dx :: Maybe (Prop Number), dy :: Maybe (Prop Number), opacity :: Maybe (Prop Number), unlockImage :: Maybe (Prop Boolean), file :: Maybe PathExpression, haloRasterizer :: Maybe (Prop HaloRasterizer), simplifyTolerance :: Maybe (Prop Number), smooth :: Maybe (Prop Number), clip :: Maybe (Prop Boolean), compOp :: Maybe (Prop CompositeMode), geometryTransform :: Maybe (Prop Transform), simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm) }
_ShieldSymbolizer = prism' ShieldSymbolizer f
  where
    f (ShieldSymbolizer r) = Just r
    f _ = Nothing

_TextSymbolizer :: Prism' Symbolizer { placements :: TextPlacements, haloCompOp :: Maybe (Prop CompositeMode), haloRasterizer :: Maybe (Prop HaloRasterizer), haloTransform :: Maybe (Prop Transform), simplifyTolerance :: Maybe (Prop Number), smooth :: Maybe (Prop Number), clip :: Maybe (Prop Boolean), compOp :: Maybe (Prop CompositeMode), geometryTransform :: Maybe (Prop Transform), simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm) }
_TextSymbolizer = prism' TextSymbolizer f
  where
    f (TextSymbolizer r) = Just r
    f _ = Nothing

_BuildingSymbolizer :: Prism' Symbolizer { fill :: Maybe (Prop Color), fillOpacity :: Maybe (Prop Number), height :: Maybe (Prop Number), simplifyTolerance :: Maybe (Prop Number), smooth :: Maybe (Prop Number), clip :: Maybe (Prop Boolean), compOp :: Maybe (Prop CompositeMode), geometryTransform :: Maybe (Prop Transform), simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm) }
_BuildingSymbolizer = prism' BuildingSymbolizer f
  where
    f (BuildingSymbolizer r) = Just r
    f _ = Nothing

_MarkersSymbolizer :: Prism' Symbolizer { file :: Maybe PathExpression, opacity :: Maybe (Prop Number), fill :: Maybe (Prop Color), fillOpacity :: Maybe (Prop Number), spacing :: Maybe (Prop Number), maxError :: Maybe (Prop Number), offset :: Maybe (Prop Number), width :: Maybe (Prop Number), height :: Maybe (Prop Number), allowOverlap :: Maybe (Prop Boolean), avoidEdges :: Maybe (Prop Boolean), ignorePlacement :: Maybe (Prop Boolean), imageTransform :: Maybe (Prop Transform), placement :: Maybe (Prop MarkerPlacement), multiPolicy :: Maybe (Prop MarkerMultiPolicy), direction :: Maybe (Prop Direction), strokeGamma :: Maybe (Prop Number), strokeGammaMethod :: Maybe (Prop GammaMethod), strokeDashArray :: Maybe (Prop (Array Dash)), strokeDashOffset :: Maybe (Prop Number), strokeMiterLimit :: Maybe (Prop Number), strokeWidth :: Maybe (Prop Number), strokeOpacity :: Maybe (Prop Number), stroke :: Maybe (Prop Color), strokeLineJoin :: Maybe (Prop LineJoin), strokeLineCap :: Maybe (Prop LineCap), simplifyTolerance :: Maybe (Prop Number), smooth :: Maybe (Prop Number), clip :: Maybe (Prop Boolean), compOp :: Maybe (Prop CompositeMode), geometryTransform :: Maybe (Prop Transform), simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm) }
_MarkersSymbolizer = prism' MarkersSymbolizer f
  where
    f (MarkersSymbolizer r) = Just r
    f _ = Nothing

_GroupSymbolizer :: Prism' Symbolizer { groupProperties :: GroupSymProperties, numColumns :: Maybe (Prop Int), startColumn :: Maybe (Prop Int), repeatKey :: Maybe (Prop Expression), placements :: TextPlacements, simplifyTolerance :: Maybe (Prop Number), smooth :: Maybe (Prop Number), clip :: Maybe (Prop Boolean), compOp :: Maybe (Prop CompositeMode), geometryTransform :: Maybe (Prop Transform), simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm) }
_GroupSymbolizer = prism' GroupSymbolizer f
  where
    f (GroupSymbolizer r) = Just r
    f _ = Nothing

_DebugSymbolizer :: Prism' Symbolizer { mode :: Maybe DebugMode, simplifyTolerance :: Maybe (Prop Number), smooth :: Maybe (Prop Number), clip :: Maybe (Prop Boolean), compOp :: Maybe (Prop CompositeMode), geometryTransform :: Maybe (Prop Transform), simplifyAlgorithm :: Maybe (Prop SimplifyAlgorithm) }
_DebugSymbolizer = prism' DebugSymbolizer f
  where
    f (DebugSymbolizer r) = Just r
    f _ = Nothing

_DotSymbolizer :: Prism' Symbolizer { fill :: Maybe (Prop Color), opacity :: Maybe (Prop Number), width :: Maybe (Prop Number), height :: Maybe (Prop Number), compOp :: Maybe (Prop CompositeMode) }
_DotSymbolizer = prism' DotSymbolizer f
  where
    f (DotSymbolizer r) = Just r
    f _ = Nothing

--------------------------------------------------------------------------------
data Prop a =
    Exp Expression
  | Val a

derive instance genericProp :: Generic (Prop a) _

instance encodeProp :: Encode a => Encode (Prop a) where encode = genericEncode jOpts

instance decodeProp :: Decode a => Decode (Prop a) where decode = genericDecode jOpts

instance showProp :: Show a => Show (Prop a) where show = GShow.genericShow

instance eqProp :: Eq a => Eq (Prop a) where eq = GEq.genericEq


--------------------------------------------------------------------------------
_Exp :: forall a. Prism' (Prop a) Expression
_Exp = prism' Exp f
  where
    f (Exp a) = Just $ a
    f _ = Nothing

_Val :: forall a. Prism' (Prop a) a
_Val = prism' Val f
  where
    f (Val a) = Just $ a
    f _ = Nothing

--------------------------------------------------------------------------------
newtype Stop =
    Stop {
      value :: Number
    , color :: Color
    , mode :: Maybe ColorizerMode
    , label :: Maybe String
    }

derive instance genericStop :: Generic Stop _

instance encodeStop :: Encode Stop where encode = genericEncode jOpts

instance decodeStop :: Decode Stop where decode = genericDecode jOpts

instance showStop :: Show Stop where show = GShow.genericShow

instance eqStop :: Eq Stop where eq = GEq.genericEq

derive instance newtypeStop :: Newtype Stop _


--------------------------------------------------------------------------------
_Stop :: Iso' Stop { value :: Number, color :: Color, mode :: Maybe ColorizerMode, label :: Maybe String}
_Stop = _Newtype

--------------------------------------------------------------------------------
newtype Colorizer =
    Colorizer {
      mode :: Maybe ColorizerMode
    , color :: Maybe Color
    , epsilon :: Maybe Number
    , stops :: Array Stop
    }

derive instance genericColorizer :: Generic Colorizer _

instance encodeColorizer :: Encode Colorizer where encode = genericEncode jOpts

instance decodeColorizer :: Decode Colorizer where decode = genericDecode jOpts

instance showColorizer :: Show Colorizer where show = GShow.genericShow

instance eqColorizer :: Eq Colorizer where eq = GEq.genericEq

derive instance newtypeColorizer :: Newtype Colorizer _


--------------------------------------------------------------------------------
_Colorizer :: Iso' Colorizer { mode :: Maybe ColorizerMode, color :: Maybe Color, epsilon :: Maybe Number, stops :: Array Stop}
_Colorizer = _Newtype

--------------------------------------------------------------------------------
newtype TextProperties =
    TextProperties {
      labelPlacement :: Maybe (Prop LabelPlacement)
    , labelSpacing :: Maybe (Prop Number)
    , labelPositionTolerance :: Maybe (Prop Number)
    , avoidEdges :: Maybe (Prop Boolean)
    , margin :: Maybe (Prop Number)
    , repeatDistance :: Maybe (Prop Number)
    , minimumDistance :: Maybe (Prop Number)
    , minimumPadding :: Maybe (Prop Number)
    , minimumPathLength :: Maybe (Prop Number)
    , maxCharAngleDelta :: Maybe (Prop Number)
    , allowOverlap :: Maybe (Prop Boolean)
    , largestBoxOnly :: Maybe (Prop Boolean)
    , upright :: Maybe (Prop Upright)
    }

derive instance genericTextProperties :: Generic TextProperties _

instance encodeTextProperties :: Encode TextProperties where encode = genericEncode jOpts

instance decodeTextProperties :: Decode TextProperties where decode = genericDecode jOpts

instance showTextProperties :: Show TextProperties where show = GShow.genericShow

instance eqTextProperties :: Eq TextProperties where eq = GEq.genericEq

derive instance newtypeTextProperties :: Newtype TextProperties _


--------------------------------------------------------------------------------
_TextProperties :: Iso' TextProperties { labelPlacement :: Maybe (Prop LabelPlacement), labelSpacing :: Maybe (Prop Number), labelPositionTolerance :: Maybe (Prop Number), avoidEdges :: Maybe (Prop Boolean), margin :: Maybe (Prop Number), repeatDistance :: Maybe (Prop Number), minimumDistance :: Maybe (Prop Number), minimumPadding :: Maybe (Prop Number), minimumPathLength :: Maybe (Prop Number), maxCharAngleDelta :: Maybe (Prop Number), allowOverlap :: Maybe (Prop Boolean), largestBoxOnly :: Maybe (Prop Boolean), upright :: Maybe (Prop Upright)}
_TextProperties = _Newtype

--------------------------------------------------------------------------------
newtype TextSymProperties =
    TextSymProperties {
      properties :: TextProperties
    , layoutProperties :: TextLayoutProperties
    , formatProperties :: TextFormatProperties
    , format :: Format
    }

derive instance genericTextSymProperties :: Generic TextSymProperties _

instance encodeTextSymProperties :: Encode TextSymProperties where encode = genericEncode jOpts

instance decodeTextSymProperties :: Decode TextSymProperties where decode = genericDecode jOpts

instance showTextSymProperties :: Show TextSymProperties where show = GShow.genericShow

instance eqTextSymProperties :: Eq TextSymProperties where eq = GEq.genericEq

derive instance newtypeTextSymProperties :: Newtype TextSymProperties _


--------------------------------------------------------------------------------
_TextSymProperties :: Iso' TextSymProperties { properties :: TextProperties, layoutProperties :: TextLayoutProperties, formatProperties :: TextFormatProperties, format :: Format}
_TextSymProperties = _Newtype

--------------------------------------------------------------------------------
newtype GroupSymProperties =
    GroupSymProperties {
      layout :: GroupLayout
    , rules :: Array GroupRule
    }

derive instance genericGroupSymProperties :: Generic GroupSymProperties _

instance encodeGroupSymProperties :: Encode GroupSymProperties where encode = genericEncode jOpts

instance decodeGroupSymProperties :: Decode GroupSymProperties where decode = genericDecode jOpts

instance showGroupSymProperties :: Show GroupSymProperties where show = GShow.genericShow

instance eqGroupSymProperties :: Eq GroupSymProperties where eq = GEq.genericEq

derive instance newtypeGroupSymProperties :: Newtype GroupSymProperties _


--------------------------------------------------------------------------------
_GroupSymProperties :: Iso' GroupSymProperties { layout :: GroupLayout, rules :: Array GroupRule}
_GroupSymProperties = _Newtype

--------------------------------------------------------------------------------
newtype GroupRule =
    GroupRule {
      symbolizers :: Array Symbolizer
    , filter :: Maybe Expression
    , repeatKey :: Maybe Expression
    }

derive instance genericGroupRule :: Generic GroupRule _

instance encodeGroupRule :: Encode GroupRule where
  encode (GroupRule x) = toForeign
    $ SM.insert "symbolizers" (toForeign (encode <$> x.symbolizers))
    $ SM.insert "filter" (encode x.filter)
    $ SM.insert "repeatKey" (encode x.repeatKey)
    $ SM.empty

instance decodeGroupRule :: Decode GroupRule where
  decode json = decode json >>= \ obj -> do
    symbolizersJ <- maybe error pure $ SM.lookup "symbolizers" obj
    symbolizers <- traverse decode =<< decode symbolizersJ
    filter <- decodeMay (SM.lookup "filter" obj)
    repeatKey <- decodeMay (SM.lookup "repeatKey" obj)
    pure (GroupRule {symbolizers,filter,repeatKey})
    where
      error = throwError $ NEL.singleton $ ForeignError "Expected field 'symbolizers'"

instance showGroupRule :: Show GroupRule where
  show (GroupRule r) = ("GroupRule { symbolizers: "
                    <> show r.symbolizers
                    <> ", filter: " <> show r.filter
                    <> ", repeatKey: " <> show r.repeatKey
                    <> "}")

instance eqGroupRule :: Eq GroupRule where
  eq (GroupRule a) (GroupRule b) = a.symbolizers `eq` b.symbolizers &&
                                   a.filter      `eq` b.filter &&
                                   a.repeatKey   `eq` b.repeatKey

derive instance newtypeGroupRule :: Newtype GroupRule _


--------------------------------------------------------------------------------
_GroupRule :: Iso' GroupRule { symbolizers :: Array Symbolizer, filter :: Maybe Expression, repeatKey :: Maybe Expression}
_GroupRule = _Newtype

--------------------------------------------------------------------------------
data GroupLayout =
    SimpleRowLayout {
      itemMargin :: Maybe Number
    }
  | PairLayout {
      itemMargin :: Maybe Number
    , maxDifference :: Maybe Number
    }

derive instance genericGroupLayout :: Generic GroupLayout _

instance encodeGroupLayout :: Encode GroupLayout where encode = genericEncode jOpts

instance decodeGroupLayout :: Decode GroupLayout where decode = genericDecode jOpts

instance showGroupLayout :: Show GroupLayout where show = GShow.genericShow

instance eqGroupLayout :: Eq GroupLayout where eq = GEq.genericEq


--------------------------------------------------------------------------------
_SimpleRowLayout :: Prism' GroupLayout { itemMargin :: Maybe Number }
_SimpleRowLayout = prism' SimpleRowLayout f
  where
    f (SimpleRowLayout r) = Just r
    f _ = Nothing

_PairLayout :: Prism' GroupLayout { itemMargin :: Maybe Number, maxDifference :: Maybe Number }
_PairLayout = prism' PairLayout f
  where
    f (PairLayout r) = Just r
    f _ = Nothing

--------------------------------------------------------------------------------
newtype TextLayoutProperties =
    TextLayoutProperties {
      dx :: Maybe (Prop Number)
    , dy :: Maybe (Prop Number)
    , orientation :: Maybe (Prop Number)
    , textRatio :: Maybe (Prop Number)
    , wrapWidth :: Maybe (Prop Number)
    , wrapChar :: Maybe (Prop String)
    , wrapBefore :: Maybe (Prop Boolean)
    , repeatWrapChar :: Maybe (Prop Boolean)
    , rotateDisplacement :: Maybe (Prop Boolean)
    , horizontalAlignment :: Maybe (Prop HorizontalAlignment)
    , justifyAlignment :: Maybe (Prop JustifyAlignment)
    , verticalAlignment :: Maybe (Prop VerticalAlignment)
    , direction :: Maybe PlacementDirection
    }

derive instance genericTextLayoutProperties :: Generic TextLayoutProperties _

instance encodeTextLayoutProperties :: Encode TextLayoutProperties where encode = genericEncode jOpts

instance decodeTextLayoutProperties :: Decode TextLayoutProperties where decode = genericDecode jOpts

instance showTextLayoutProperties :: Show TextLayoutProperties where show = GShow.genericShow

instance eqTextLayoutProperties :: Eq TextLayoutProperties where eq = GEq.genericEq

derive instance newtypeTextLayoutProperties :: Newtype TextLayoutProperties _


--------------------------------------------------------------------------------
_TextLayoutProperties :: Iso' TextLayoutProperties { dx :: Maybe (Prop Number), dy :: Maybe (Prop Number), orientation :: Maybe (Prop Number), textRatio :: Maybe (Prop Number), wrapWidth :: Maybe (Prop Number), wrapChar :: Maybe (Prop String), wrapBefore :: Maybe (Prop Boolean), repeatWrapChar :: Maybe (Prop Boolean), rotateDisplacement :: Maybe (Prop Boolean), horizontalAlignment :: Maybe (Prop HorizontalAlignment), justifyAlignment :: Maybe (Prop JustifyAlignment), verticalAlignment :: Maybe (Prop VerticalAlignment), direction :: Maybe PlacementDirection}
_TextLayoutProperties = _Newtype

--------------------------------------------------------------------------------
newtype TextFormatProperties =
    TextFormatProperties {
      font :: Maybe Font
    , textSize :: Maybe (Prop Number)
    , characterSpacing :: Maybe (Prop Number)
    , lineSpacing :: Maybe (Prop Number)
    , textOpacity :: Maybe (Prop Number)
    , haloOpacity :: Maybe (Prop Number)
    , textTransform :: Maybe (Prop TextTransform)
    , fill :: Maybe (Prop Color)
    , haloFill :: Maybe (Prop Color)
    , haloRadius :: Maybe (Prop Number)
    , ffSettings :: Maybe (Prop FontFeatureSettings)
    }

derive instance genericTextFormatProperties :: Generic TextFormatProperties _

instance encodeTextFormatProperties :: Encode TextFormatProperties where encode = genericEncode jOpts

instance decodeTextFormatProperties :: Decode TextFormatProperties where decode = genericDecode jOpts

instance showTextFormatProperties :: Show TextFormatProperties where show = GShow.genericShow

instance eqTextFormatProperties :: Eq TextFormatProperties where eq = GEq.genericEq

derive instance newtypeTextFormatProperties :: Newtype TextFormatProperties _


--------------------------------------------------------------------------------
_TextFormatProperties :: Iso' TextFormatProperties { font :: Maybe Font, textSize :: Maybe (Prop Number), characterSpacing :: Maybe (Prop Number), lineSpacing :: Maybe (Prop Number), textOpacity :: Maybe (Prop Number), haloOpacity :: Maybe (Prop Number), textTransform :: Maybe (Prop TextTransform), fill :: Maybe (Prop Color), haloFill :: Maybe (Prop Color), haloRadius :: Maybe (Prop Number), ffSettings :: Maybe (Prop FontFeatureSettings)}
_TextFormatProperties = _Newtype

--------------------------------------------------------------------------------
data Format =
    FormatExp Expression
  | FormatList (Array Format)
  | Format {
      font :: Maybe Font
    , textSize :: Maybe (Prop Number)
    , opacity :: Maybe (Prop Number)
    , characterSpacing :: Maybe (Prop Number)
    , lineSpacing :: Maybe (Prop Number)
    , wrapBefore :: Maybe (Prop Boolean)
    , repeatWrapChar :: Maybe (Prop Boolean)
    , textTransform :: Maybe (Prop TextTransform)
    , fill :: Maybe (Prop Color)
    , haloFill :: Maybe (Prop Color)
    , haloRadius :: Maybe (Prop Number)
    , ffSettings :: Maybe (Prop FontFeatureSettings)
    , next :: Format
    }
  | FormatLayout {
      dx :: Maybe (Prop Number)
    , dy :: Maybe (Prop Number)
    , orientation :: Maybe (Prop Number)
    , textRatio :: Maybe (Prop Number)
    , wrapWidth :: Maybe (Prop Number)
    , wrapChar :: Maybe (Prop String)
    , wrapBefore :: Maybe (Prop Boolean)
    , repeatWrapChar :: Maybe (Prop Boolean)
    , rotateDisplacement :: Maybe (Prop Boolean)
    , horizontalAlignment :: Maybe (Prop HorizontalAlignment)
    , justifyAlignment :: Maybe (Prop JustifyAlignment)
    , verticalAlignment :: Maybe (Prop VerticalAlignment)
    , next :: Format
    }
  | NullFormat

derive instance genericFormat :: Generic Format _

instance encodeFormat :: Encode Format where
  encode (FormatExp e) = toForeign $ SM.insert "FormatExp" (encode e) $ SM.empty
  encode (FormatList xs) = toForeign $ SM.insert "FormatList" o $ SM.empty
    where o = toForeign (encode <$> xs)
  encode (Format f) = toForeign $ SM.insert "Format" o $ SM.empty
    where o = toForeign
            $ SM.insert "font" (encode f.font)
            $ SM.insert "textSize" (encode f.textSize)
            $ SM.insert "opacity" (encode f.opacity)
            $ SM.insert "characterSpacing" (encode f.characterSpacing)
            $ SM.insert "lineSpacing" (encode f.lineSpacing)
            $ SM.insert "wrapBefore" (encode f.wrapBefore)
            $ SM.insert "repeatWrapChar" (encode f.repeatWrapChar)
            $ SM.insert "textTransform" (encode f.textTransform)
            $ SM.insert "fill" (encode f.fill)
            $ SM.insert "haloFill" (encode f.haloFill)
            $ SM.insert "haloRadius" (encode f.haloRadius)
            $ SM.insert "ffSettings" (encode f.ffSettings)
            $ SM.insert "next" (encode f.next)
            $ SM.empty
  encode (FormatLayout f) = toForeign $ SM.insert "FormatLayout" o $ SM.empty
    where o = toForeign
            $ SM.insert "dx" (encode f.dx)
            $ SM.insert "dy" (encode f.dy)
            $ SM.insert "orientation" (encode f.orientation)
            $ SM.insert "textRatio" (encode f.textRatio)
            $ SM.insert "wrapWidth" (encode f.wrapWidth)
            $ SM.insert "wrapChar" (encode f.wrapChar)
            $ SM.insert "wrapBefore" (encode f.wrapBefore)
            $ SM.insert "repeatWrapChar" (encode f.repeatWrapChar)
            $ SM.insert "rotateDisplacement" (encode f.rotateDisplacement)
            $ SM.insert "horizontalAlignment" (encode f.horizontalAlignment)
            $ SM.insert "justifyAlignment" (encode f.justifyAlignment)
            $ SM.insert "verticalAlignment" (encode f.verticalAlignment)
            $ SM.insert "next" (encode f.next)
            $ SM.empty
  encode NullFormat = toForeign $ SM.insert "NullFormat" o $ SM.empty
    where o = toForeign []

instance decodeFormat :: Decode Format where
  decode json = decode json >>= \ o ->
    maybe invalid id (head (SM.toArrayWithKey go o))
    where
      go :: String -> Foreign -> F Format
      go "NullFormat" _ = pure NullFormat
      go "FormatList" xs =
        FormatList <$> (traverse decode =<< decode xs)
      go "Format" f = decode f >>= \ o -> do
        font <- decodeMay (SM.lookup "font" o)
        textSize <- decodeMay (SM.lookup "textSize" o)
        opacity <- decodeMay (SM.lookup "opacity" o)
        characterSpacing <- decodeMay (SM.lookup "characterSpacing" o)
        lineSpacing <- decodeMay (SM.lookup "lineSpacing" o)
        wrapBefore <- decodeMay (SM.lookup "wrapBefore" o)
        repeatWrapChar <- decodeMay (SM.lookup "repeatWrapChar" o)
        textTransform <- decodeMay (SM.lookup "textTransform" o)
        fill <- decodeMay (SM.lookup "fill" o)
        haloFill <- decodeMay (SM.lookup "haloFill" o)
        haloRadius <- decodeMay (SM.lookup "haloRadius" o)
        ffSettings <- decodeMay (SM.lookup "ffSettings" o)
        next <- maybe error decode (SM.lookup "next" o)
        pure (Format {font,textSize,opacity,characterSpacing,lineSpacing,wrapBefore,repeatWrapChar,textTransform,fill,haloFill,haloRadius,ffSettings,next})
      go "FormatLayout" f = decode f >>= \ o -> do
        dx <- decodeMay (SM.lookup "dx" o)
        dy <- decodeMay (SM.lookup "dy" o)
        orientation <- decodeMay (SM.lookup "orientation" o)
        textRatio <- decodeMay (SM.lookup "textRatio" o)
        wrapWidth <- decodeMay (SM.lookup "wrapWidth" o)
        wrapChar <- decodeMay (SM.lookup "wrapChar" o)
        wrapBefore <- decodeMay (SM.lookup "wrapBefore" o)
        repeatWrapChar <- decodeMay (SM.lookup "repeatWrapChar" o)
        rotateDisplacement <- decodeMay (SM.lookup "rotateDisplacement" o)
        horizontalAlignment <- decodeMay (SM.lookup "horizontalAlignment" o)
        justifyAlignment <- decodeMay (SM.lookup "justifyAlignment" o)
        verticalAlignment <- decodeMay (SM.lookup "verticalAlignment" o)
        next <- maybe error decode (SM.lookup "next" o)
        pure (FormatLayout
             {dx,dy,orientation,textRatio,wrapWidth,wrapBefore,wrapChar,repeatWrapChar,rotateDisplacement,horizontalAlignment,justifyAlignment,verticalAlignment,next})
      go _ _ = invalid

      error = throwError $ NEL.singleton $ ForeignError "Expected 'next' key"
      invalid = throwError $ NEL.singleton $ ForeignError "Invalid Format"

instance showFormat :: Show Format where
  show (FormatExp e) = "FormatExp " <> show e
  show (FormatList e) = "FormatList " <> show e
  show (FormatList e) = "FormatList " <> show e
  show (Format f) = "Format { "
                 <> "font: " <> show f.font <> ", "
                 <> "textSize: " <> show f.textSize <> ", "
                 <> "opacity: " <> show f.opacity <> ", "
                 <> "characterSpacing: " <> show f.characterSpacing <> ", "
                 <> "lineSpacing: " <> show f.lineSpacing <> ", "
                 <> "wrapBefore: " <> show f.wrapBefore <> ", "
                 <> "repeatWrapChar: " <> show f.repeatWrapChar <> ", "
                 <> "textTransform: " <> show f.textTransform <> ", "
                 <> "fill: " <> show f.fill <> ", "
                 <> "haloFill: " <> show f.haloFill <> ", "
                 <> "ffSettings: " <> show f.ffSettings <> ", "
                 <> "next: " <> show f.next <> "}"
  show (FormatLayout f) = "FormatLayout { "
                 <> "dx: " <> show f.dx <> ", "
                 <> "dy: " <> show f.dy <> ", "
                 <> "orientation: " <> show f.orientation <> ", "
                 <> "textRatio: " <> show f.textRatio <> ", "
                 <> "wrapWidth: " <> show f.wrapWidth <> ", "
                 <> "wrapChar: " <> show f.wrapChar <> ", "
                 <> "wrapBefore: " <> show f.wrapBefore <> ", "
                 <> "repeatWrapChar: " <> show f.repeatWrapChar <> ", "
                 <> "horizontalAlignment: " <> show f.horizontalAlignment <> ", "
                 <> "justifyAlignment: " <> show f.justifyAlignment <> ", "
                 <> "verticalAlignment: " <> show f.verticalAlignment <> ", "
                 <> "next: " <> show f.next <> "}"
  show NullFormat = "NullFormat"

instance eqFormat :: Eq Format where
  eq (FormatExp a) (FormatExp b) = eq a b
  eq (FormatList a) (FormatList b) = eq a b
  eq (Format a) (Format b) = eq a.font b.font
                          && eq a.textSize b.textSize
                          && eq a.opacity b.opacity
                          && eq a.lineSpacing b.lineSpacing
                          && eq a.wrapBefore b.wrapBefore
                          && eq a.repeatWrapChar b.repeatWrapChar
                          && eq a.textTransform b.textTransform
                          && eq a.fill b.fill
                          && eq a.haloFill b.haloFill
                          && eq a.haloRadius b.haloRadius
                          && eq a.ffSettings b.ffSettings
                          && eq a.next b.next
  eq (FormatLayout a) (FormatLayout b) = eq a.dx b.dx
                                      && eq a.dy b.dy
                                      && eq a.orientation b.orientation
                                      && eq a.textRatio b.textRatio
                                      && eq a.wrapWidth b.wrapWidth
                                      && eq a.wrapChar b.wrapChar
                                      && eq a.wrapBefore b.wrapBefore
                                      && eq a.repeatWrapChar b.repeatWrapChar
                                      && eq a.rotateDisplacement b.rotateDisplacement
                                      && eq a.horizontalAlignment b.horizontalAlignment
                                      && eq a.justifyAlignment b.justifyAlignment
                                      && eq a.verticalAlignment b.verticalAlignment
                                      && eq a.next b.next
  eq NullFormat NullFormat = true
  eq _ _ = false


--------------------------------------------------------------------------------
_FormatExp :: Prism' Format Expression
_FormatExp = prism' FormatExp f
  where
    f (FormatExp a) = Just $ a
    f _ = Nothing

_FormatList :: Prism' Format (Array Format)
_FormatList = prism' FormatList f
  where
    f (FormatList a) = Just $ a
    f _ = Nothing

_Format :: Prism' Format { font :: Maybe Font, textSize :: Maybe (Prop Number), opacity :: Maybe (Prop Number), characterSpacing :: Maybe (Prop Number), lineSpacing :: Maybe (Prop Number), wrapBefore :: Maybe (Prop Boolean), repeatWrapChar :: Maybe (Prop Boolean), textTransform :: Maybe (Prop TextTransform), fill :: Maybe (Prop Color), haloFill :: Maybe (Prop Color), haloRadius :: Maybe (Prop Number), ffSettings :: Maybe (Prop FontFeatureSettings), next :: Format }
_Format = prism' Format f
  where
    f (Format r) = Just r
    f _ = Nothing

_FormatLayout :: Prism' Format { dx :: Maybe (Prop Number), dy :: Maybe (Prop Number), orientation :: Maybe (Prop Number), textRatio :: Maybe (Prop Number), wrapWidth :: Maybe (Prop Number), wrapChar :: Maybe (Prop String), wrapBefore :: Maybe (Prop Boolean), repeatWrapChar :: Maybe (Prop Boolean), rotateDisplacement :: Maybe (Prop Boolean), horizontalAlignment :: Maybe (Prop HorizontalAlignment), justifyAlignment :: Maybe (Prop JustifyAlignment), verticalAlignment :: Maybe (Prop VerticalAlignment), next :: Format }
_FormatLayout = prism' FormatLayout f
  where
    f (FormatLayout r) = Just r
    f _ = Nothing

_NullFormat :: Prism' Format Unit
_NullFormat = prism' (\_ -> NullFormat) f
  where
    f NullFormat = Just unit
    f _ = Nothing

--------------------------------------------------------------------------------
newtype TextPlacements =
    Dummy TextSymProperties

derive instance genericTextPlacements :: Generic TextPlacements _

instance encodeTextPlacements :: Encode TextPlacements where encode = genericEncode jOpts

instance decodeTextPlacements :: Decode TextPlacements where decode = genericDecode jOpts

instance showTextPlacements :: Show TextPlacements where show = GShow.genericShow

instance eqTextPlacements :: Eq TextPlacements where eq = GEq.genericEq

derive instance newtypeTextPlacements :: Newtype TextPlacements _


--------------------------------------------------------------------------------
_Dummy :: Iso' TextPlacements TextSymProperties
_Dummy = _Newtype
--------------------------------------------------------------------------------
data Font =
    FontSetName String
  | FaceName String

derive instance genericFont :: Generic Font _

instance encodeFont :: Encode Font where encode = genericEncode jOpts

instance decodeFont :: Decode Font where decode = genericDecode jOpts

instance showFont :: Show Font where show = GShow.genericShow

instance eqFont :: Eq Font where eq = GEq.genericEq


--------------------------------------------------------------------------------
_FontSetName :: Prism' Font String
_FontSetName = prism' FontSetName f
  where
    f (FontSetName a) = Just $ a
    f _ = Nothing

_FaceName :: Prism' Font String
_FaceName = prism' FaceName f
  where
    f (FaceName a) = Just $ a
    f _ = Nothing

--------------------------------------------------------------------------------
